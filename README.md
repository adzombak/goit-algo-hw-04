# goit-algo-hw-04

small_array = 1 000 random numbers \
medium_array = 10 000 random numbers \
big_array = 20 000 random numbers


| Algorithm            | Time of small array  | Time of medium array | Time of big array    | Relation to Timsort (Big array)     |
| -------------------- | -------------------- | -------------------- | -------------------- | ----------------------------------- |
| Insertion sort       |              0.02456 |              2.39561 |              9.50556 |                         22824.78445 |
| Merge sort           |              0.00560 |              0.06532 |              0.13951 |                           334.98446 |
| Timsorted            |              0.00002 |              0.00028 |              0.00057 |                             1.37969 |
| Timsort              |              0.00002 |              0.00021 |              0.00042 |                             1.00000 |


### Висновки за результатами порівняльного аналізу алгоритмів сортування

1. **Час виконання алгоритмів на великих масивах даних**:
   - **Insertion sort** демонструє найгіршу продуктивність порівняно з Merge sort і Timsort, і є в 22824 разів повільніший за Timsort.
   - **Merge sort** показує досить добру швидкодію на великих масивах даних, але відстає від Timsort, що підтверджує його ефективність.
   - **Timsort** виявився найшвидшим серед усіх тестованих алгоритмів, навіть порівняно з вбудованою функцією сортування Python `sorted`.

2. **Ефективність Timsort**:
   - Поєднання сортування злиттям і сортування вставками у Timsort дозволяє досягти набагато кращої продуктивності в порівнянні з іншими алгоритмами.
   - Емпіричні дані підтверджують теоретичні оцінки складності алгоритмів і підтверджують вибір програмістами використовувати вбудовані в Python алгоритми сортування, такі як Timsort.

Отже, результати емпіричного дослідження підтверджують, що поєднання сортування злиттям і сортування вставками у Timsort робить його набагато ефективнішим порівняно з іншими алгоритмами сортування.
